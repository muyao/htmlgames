<!DOCTYPE html>
<html>

<head>
    <title>
        JSCraft
    </title>
</head>

<body>
    <canvas id="canvas" tabindex="0" style="border:1px solid black" onclick="Sys.start();"
        onkeydown="Controls.keyDown();" onkeyup="Controls.keyUp();"></canvas>
    <p id="debug"></p>
    <script>
        "use strict";

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 960;
        canvas.height = 720;
        ctx.save();

        // =======================================================================================
        // ------- CODE AREA -------

        const Sys = {
            hasStarted: false,
            time: Date.now(),
            mspt: 33,
            fps: 30,
            trisRendered: 0,

            start: function () {
                if (!Sys.hasStarted) {
                    Sys.hasStarted = true;
                }
            },

            updData: function () {
                Sys.mspt = Date.now() - this.time;
                Sys.fps = Math.floor(1000 / Sys.mspt);
                Sys.time = Date.now();

                Sys.trisRendered = 0;
            },

            tick: function () { // tick
                Sys.updData();

                Debug.set("");
                Debug.log("MSPT: " + Sys.mspt);
                Debug.log("FPS: " + Sys.fps);
                Debug.log("Time: " + Math.floor(Sys.time));
                Debug.log("Has Started: " + Sys.hasStarted);
                Debug.log("Keys: [" + Controls.keys + "]");

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (Sys.hasStarted) {

                    Controls.checkControls();

                    Player.vy -= 0.022;
                    Player.cleanAngs();

                    Player.vx *= 0.8;
                    Player.vy *= 0.98;
                    Player.vz *= 0.8;

                    Player.move(Player.vx, Player.vy, Player.vz);

                    Camera.x = Player.x;
                    Camera.y = Player.y + 1.62;
                    Camera.z = Player.z;
                    Camera.pitch = Player.pitch;
                    Camera.yaw = Player.yaw;
                    Camera.roll = Player.roll;

                    if (Player.breakProgress > 7) {
                        Player.breakBlock(Player.selX, Player.selY, Player.selZ);
                    }
                    if (Player.willPlace) {
                        Player.placeBlock(Player.selAxis, Player.selX, Player.selY, Player.selZ);
                    }
                    EntEngine.hitbox(Player.x, Player.y, Player.z, 0.8, 1.8, 0.8, true);
                    Player.selectBlock();

                    ctx.save();
                    ctx.setTransform(canvas.width / Srcs.misc.sky[0].width, 0, 0, canvas.height / Srcs.misc.sky[0].height, 0, 0);
                    ctx.drawImage(Srcs.misc.sky[0], 0, 0);
                    ctx.restore();

                    Render.updateAll();

                    Render.render();

                    if (!(Player.selAxis === undefined)) {
                        Render.face(Srcs.misc.select, Player.selAxis, Player.selX, Player.selY, Player.selZ);
                    }

                    ctx.drawImage(Srcs.ui.crosshair[0], (canvas.width - Srcs.ui.crosshair[0].width) / 2, (canvas.height - Srcs.ui.crosshair[0].height) / 2);

                    Debug.log("Tris Rendered: " + Sys.trisRendered);
                    Debug.log("Selected Block: " + Player.selX + ", " + Player.selY + ", " + Player.selZ + ", " + Player.selAxis);

                } else {

                    ctx.font = "96px serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("Click to Start", canvas.width / 2, canvas.height / 2);

                }
            },
        };

        const Debug = {
            set: function (setTo) {
                document.getElementById("debug").innerHTML = setTo;
            },

            log: function (log) {
                document.getElementById("debug").innerHTML += "<br>";
                document.getElementById("debug").innerHTML += log;
            },
        };

        const Controls = {
            keys: [],

            keyDown: function () {
                if (!Controls.keys.includes(event.key)) {
                    Controls.keys.push(event.key);
                }
            },

            keyUp: function () {
                Controls.keys.splice(Controls.keys.indexOf(event.key), 1);
            },

            checkControls: function () {
                if (Controls.keys.includes("j")) {
                    Player.vyaw -= 0.012;
                }
                if (Controls.keys.includes("l")) {
                    Player.vyaw += 0.012;
                }
                if (Controls.keys.includes("k")) {
                    Player.vpitch -= 0.012;
                }
                if (Controls.keys.includes("i")) {
                    Player.vpitch += 0.012;
                }

                Player.pitch += Player.vpitch;
                Player.yaw += Player.vyaw;
                Player.roll += Player.vroll;

                Player.vpitch *= 0.8;
                Player.vyaw *= 0.8;
                Player.vroll *= 0.8;

                if (Controls.keys.includes("s")) {
                    Player.vx += Player.walkSpeed * Math.sin(Player.yaw);
                    Player.vz += Player.walkSpeed * Math.cos(Player.yaw);
                }
                if (Controls.keys.includes("w")) {
                    Player.vx -= Player.walkSpeed * Math.sin(Player.yaw);
                    Player.vz -= Player.walkSpeed * Math.cos(Player.yaw);
                }
                if (Controls.keys.includes("d")) {
                    Player.vx += Player.walkSpeed * Math.sin(Player.yaw - Math.PI / 2);
                    Player.vz += Player.walkSpeed * Math.cos(Player.yaw - Math.PI / 2);
                }
                if (Controls.keys.includes("a")) {
                    Player.vx -= Player.walkSpeed * Math.sin(Player.yaw - Math.PI / 2);
                    Player.vz -= Player.walkSpeed * Math.cos(Player.yaw - Math.PI / 2);
                }
                if (Controls.keys.includes("e")) {
                    Player.vy += 0.1;
                }
                if (Controls.keys.includes("q")) {
                    if (!Controls.keys.includes("e")) {
                        Player.vy = 0.022;
                    }
                }
                if (Controls.keys.includes(" ")) {
                    if (Player.isOnGround) {
                        Player.vy = 0.26;
                    }
                }
                if (Controls.keys.includes("u")) {
                    Player.breakProgress = 8;
                } else {
                    Player.breakProgress = 0;
                }
                if (Controls.keys.includes("o")) {
                    Player.willPlace = true;
                } else {
                    Player.willPlace = false;
                    Player.hasPlaced = false;
                }
            }
        };

        const Player = {
            x: 8,
            y: 5,
            z: 8,
            pitch: 0,
            yaw: Math.PI,
            roll: 0,
            vx: 0,
            vy: 0,
            vz: 0,
            vpitch: 0,
            vyaw: 0,
            vroll: 0,
            walkSpeed: 0.035,
            isOnGround: false,
            selX: undefined,
            selY: undefined,
            selZ: undefined,
            selAxis: undefined,
            breakProgress: 0,
            willPlace: false,
            hasPlaced: false,

            breakBlock: function (x, y, z) {
                World.setBlock("block:air", x, y, z);
            },

            placeBlock: function (axis, x, y, z) {
                if (!Player.hasPlaced) {
                    Player.hasPlaced = true;
                    if (axis === "+x") {
                        if (World.getBlockDat(x + 1, y, z)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x + 1, y, z);
                        }
                    } else if (axis === "-x") {
                        if (World.getBlockDat(x - 1, y, z)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x - 1, y, z);
                        }
                    } else if (axis === "+y") {
                        if (World.getBlockDat(x, y + 1, z)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x, y + 1, z);
                        }
                    } else if (axis === "-y") {
                        if (World.getBlockDat(x, y - 1, z)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x, y - 1, z);
                        }
                    } else if (axis === "+z") {
                        if (World.getBlockDat(x, y, z + 1)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x, y, z + 1);
                        }
                    } else if (axis === "-z") {
                        if (World.getBlockDat(x, y, z - 1)[0] === "block:air") {
                            World.setBlock("block:cobblestone", x, y, z - 1);
                        }
                    } else if (!axis === undefined) {
                        console.error("Wrong axis input: " + axis);
                    }
                }
            },

            move: function (dx, dy, dz) {
                Player.x += dx;
                if (EntEngine.hitbox(Player.x, Player.y, Player.z, 0.8, 1.8, 0.8, false)) {
                    Player.x -= dx;
                    Player.vx = 0;
                }
                Player.y += dy;
                if (EntEngine.hitbox(Player.x, Player.y, Player.z, 0.8, 1.8, 0.8, false)) {
                    Player.y -= dy;
                    Player.vy = 0;
                    Player.isOnGround = true;
                } else {
                    Player.isOnGround = false;
                }
                Player.z += dz;
                if (EntEngine.hitbox(Player.x, Player.y, Player.z, 0.8, 1.8, 0.8, false)) {
                    Player.z -= dz;
                    Player.vz = 0;
                }
            },

            cleanAngs: function () {
                if (Player.pitch > Math.PI / 2) {
                    Player.pitch = Math.PI / 2;
                } else if (Player.pitch < -Math.PI / 2) {
                    Player.pitch = -Math.PI / 2;
                }

                if (Player.yaw > 2 * Math.PI) {
                    Player.yaw = 0;
                } else if (Player.yaw < 0) {
                    Player.yaw = 2 * Math.PI;
                }
            },

            ray: function (fromx, fromy, fromz, pitch, yaw, maxd) {
                let x = fromx;
                let y = fromy;
                let z = fromz;
                let dx = 0;
                let dy = 0;
                let dz = 0;
                while (Engine.dist(dx, dy, dz) <= maxd && (World.getBlockDat(Math.floor(x), Math.floor(y), Math.floor(z))[0] === "block:air")) {
                    x -= 0.01 * Math.cos(pitch) * Math.sin(yaw);
                    y += 0.01 * Math.sin(pitch);
                    z -= 0.01 * Math.cos(pitch) * Math.cos(yaw);
                    dx += Math.abs(0.01 * Math.cos(pitch) * Math.sin(yaw));
                    dy += Math.abs(0.01 * Math.sin(pitch));
                    dz += Math.abs(0.01 * Math.cos(pitch) * Math.cos(yaw));
                }
                if (World.getBlockDat(Math.floor(x), Math.floor(y), Math.floor(z))[0] === "block:air") {
                    return [-1, -1, -1, undefined];
                } else {
                    const blockX = Math.abs(0.5 - Math.abs(x - Math.floor(x)));
                    const blockY = Math.abs(0.5 - Math.abs(y - Math.floor(y)));
                    const blockZ = Math.abs(0.5 - Math.abs(z - Math.floor(z)));
                    if (Math.max(blockX, blockY, blockZ) === blockX) {
                        if (fromx > x) {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "+x"];
                        } else {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "-x"];
                        }
                    } else if (Math.max(blockX, blockY, blockZ) === blockY) {
                        if (fromy > y) {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "+y"];
                        } else {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "-y"];
                        }
                    } else if (Math.max(blockX, blockY, blockZ) === blockZ) {
                        if (fromz > z) {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "+z"];
                        } else {
                            return [Math.floor(x), Math.floor(y), Math.floor(z), "-z"];
                        }
                    } else {
                        return [Math.floor(x), Math.floor(y), Math.floor(z), undefined];
                    }
                }
            },

            selectBlock: function () {
                let temp = Player.ray(Camera.x, Camera.y, Camera.z, Player.pitch, Player.yaw, 6.5);
                Player.selX = temp[0];
                Player.selY = temp[1];
                Player.selZ = temp[2];
                Player.selAxis = temp[3];
            },
        };

        const EntEngine = {
            hitbox: function (cx, by, cz, sx, sy, sz, canDestroy) {
                let dat = undefined;
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        for (let k = 0; k < 4; k++) {
                            dat = World.getBlockDat(Math.floor(cx - sx / 2 + i * sx / 3), Math.floor(by + j * sy / 3), Math.floor(cz - sz / 2 + k * sz / 3))[0];
                            if (!(dat === "block:air")) {
                                if (canDestroy) {
                                    World.setBlock("block:air", Math.floor(cx - sx / 2 + i * sx / 3), Math.floor(by + j * sy / 3), Math.floor(cz - sz / 2 + k * sz / 3));
                                } else {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            },
        };

        const Camera = {
            x: 0,
            y: 0,
            z: 0,
            pitch: 0,
            yaw: 0,
            roll: 0,
            fl: 350,
        };

        const Engine = {
            rotate: function (x, y, ax, ay, a) {
                return [
                    (x - ax) * Math.cos(a) - (y - ay) * Math.sin(a) + ax,
                    (x - ax) * Math.sin(a) + (y - ay) * Math.cos(a) + ay,
                ];
            },

            fill: function (tlX, tlY, blX, blY, trX, trY, texture, tsX, tsY) {
                ctx.save();
                ctx.setTransform((trX - tlX) / tsX, (trY - tlY) / tsY, (blX - tlX) / tsX, (blY - tlY) / tsY, tlX, tlY);
                ctx.drawImage(texture, 0, 0);
                ctx.restore();

                Sys.trisRendered += 1;
            },

            goTo: function (x, y, z) {
                let tempX = x;
                let tempY = y;
                let tempZ = z;
                let temp = Engine.rotate(tempX, tempZ, Camera.x, Camera.z, Camera.yaw);
                tempX = temp[0];
                tempZ = temp[1];
                temp = Engine.rotate(tempZ, tempY, Camera.z, Camera.y, Camera.pitch);
                tempZ = temp[0];
                tempY = temp[1];
                temp = Engine.rotate(tempY, tempX, Camera.y, Camera.x, Camera.roll);
                tempY = temp[0];
                tempX = temp[1];
                if (tempZ - Camera.z < -0.1) {
                    return [
                        Camera.fl * (tempX - Camera.x) / (tempZ - Camera.z) + canvas.width / 2,
                        Camera.fl * (tempY - Camera.y) / (tempZ - Camera.z) + canvas.height / 2,
                    ];
                } else {
                    return false;
                }
            },

            face: function (texture1, texture2, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
                let temp1 = Engine.goTo(x1, y1, z1);
                if (!(temp1 === false)) {
                    let temp2 = Engine.goTo(x2, y2, z2);
                    if (!(temp2 === false)) {
                        let temp3 = Engine.goTo(x3, y3, z3);
                        if (!(temp3 === false)) {
                            Engine.fill(temp1[0], temp1[1], temp2[0], temp2[1], temp3[0], temp3[1], texture1, 16, 16);
                        }
                    }
                }
                temp1 = Engine.goTo(x4, y4, z4);
                if (!(temp1 === false)) {
                    let temp3 = Engine.goTo(x2, y2, z2);
                    if (!(temp3 === false)) {
                        let temp2 = Engine.goTo(x3, y3, z3);
                        if (!(temp2 === false)) {
                            Engine.fill(temp1[0], temp1[1], temp2[0], temp2[1], temp3[0], temp3[1], texture2, 16, 16);
                        }
                    }
                }
            },

            dist: function (x, y, z) {
                return Math.sqrt(x ** 2 + y ** 2 + z ** 2);
            },
        };

        const Render = {
            faces: [],
            updates: [],

            updateAll: function () {
                let updx = undefined;
                let updy = undefined;
                let updz = undefined;
                for (let update of Render.updates) {
                    updy = Math.floor(update / World.ysize ** 2);
                    updz = Math.floor((update - World.ysize ** 2 * updy) / World.zsize);
                    updx = update - World.ysize ** 2 * updy - World.zsize * updz;
                    Render.updAddFace(updx, updy, updz);
                }

                Render.updates = [];
            },

            delFace: function (axis, x, y, z) {
                if (Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes([axis, x, y, z].toString())) {
                    Render.faces.splice(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).indexOf([axis, x, y, z].toString()), 1);
                }
            },

            updAddFace: function (x, y, z) {
                const thisBlock = World.getBlockDat(x, y, z)[0];

                if (thisBlock === "block:air") {
                    Render.delFace("+x", x, y, z);
                    Render.delFace("-x", x, y, z);
                    Render.delFace("+y", x, y, z);
                    Render.delFace("-y", x, y, z);
                    Render.delFace("+z", x, y, z);
                    Render.delFace("-z", x, y, z);
                } else {
                    let thatBlock = World.getBlockDat(x + 1, y, z)[0];
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["+x", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "+x", x, y, z]);
                        }
                    } else {
                        Render.delFace("+x", x, y, z);
                    }
                    thatBlock = World.getBlockDat(x - 1, y, z)[0]
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["-x", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "-x", x, y, z])
                        }
                    } else {
                        Render.delFace("-x", x, y, z);
                    }
                    thatBlock = World.getBlockDat(x, y + 1, z)[0]
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["+y", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "+y", x, y, z])
                        }
                    } else {
                        Render.delFace("+y", x, y, z);
                    }
                    thatBlock = World.getBlockDat(x, y - 1, z)[0]
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["-y", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "-y", x, y, z])
                        }
                    } else {
                        Render.delFace("-y", x, y, z);
                    }
                    thatBlock = World.getBlockDat(x, y, z + 1)[0]
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["+z", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "+z", x, y, z])
                        }
                    } else {
                        Render.delFace("+z", x, y, z);
                    }
                    thatBlock = World.getBlockDat(x, y, z - 1)[0]
                    if (thatBlock === "block:air") {
                        if (!(Render.faces.map((a) => [a[1], a[2], a[3], a[4]].toString()).includes(["-z", x, y, z].toString()))) {
                            Render.faces.push([Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf(thisBlock) + 1], "-z", x, y, z])
                        }
                    } else {
                        Render.delFace("-z", x, y, z);
                    }
                }

            },

            addUpdate: function (x, y, z) {
                if (!(World.getBlockDat(x, y, z)[0] === "block:air")) {
                    if (!Render.updates.includes(World.ysize ** 2 * y + World.zsize * z + x)) {
                        Render.updates.push(World.ysize ** 2 * y + World.zsize * z + x);
                    }
                }
            },

            forceAddUpdate: function (x, y, z) {
                if (!Render.updates.includes(World.ysize ** 2 * y + World.zsize * z + x)) {
                    Render.updates.push(World.ysize ** 2 * y + World.zsize * z + x);
                }
            },

            render: function () {
                Render.faces.sort(function (a, b) { return Engine.dist(b[2] - Camera.x, b[3] - Camera.y, b[4] - Camera.z) - Engine.dist(a[2] - Camera.x, a[3] - Camera.y, a[4] - Camera.z) })
                for (let face of Render.faces) {
                    Render.face(face[0], face[1], face[2], face[3], face[4]);
                }
            },

            face: function (texture, axis, x, y, z) {
                if (axis === "+z") {
                    if (Camera.z > z + 1) {
                        Engine.face(texture[0], texture[1], x, y + 1, z + 1, x, y, z + 1, x + 1, y + 1, z + 1, x + 1, y, z + 1);
                    }
                } else if (axis === "-z") {
                    if (Camera.z < z) {
                        Engine.face(texture[0], texture[1], x, y + 1, z, x, y, z, x + 1, y + 1, z, x + 1, y, z);
                    }
                } else if (axis === "+x") {
                    if (Camera.x > x + 1) {
                        Engine.face(texture[0], texture[1], x + 1, y + 1, z, x + 1, y, z, x + 1, y + 1, z + 1, x + 1, y, z + 1);
                    }
                } else if (axis === "-x") {
                    if (Camera.x < x) {
                        Engine.face(texture[0], texture[1], x, y + 1, z, x, y, z, x, y + 1, z + 1, x, y, z + 1);
                    }
                } else if (axis === "+y") {
                    if (Camera.y > y + 1) {
                        Engine.face(texture[4], texture[5], x + 1, y + 1, z, x, y + 1, z, x + 1, y + 1, z + 1, x, y + 1, z + 1);
                    }
                } else if (axis === "-y") {
                    if (Camera.y < y) {
                        Engine.face(texture[2], texture[3], x + 1, y, z, x, y, z, x + 1, y, z + 1, x, y, z + 1);
                    }
                } else {
                    console.error("Wrong axis input: " + axis);
                }
            },
        };

        const World = {
            xsize: 16,
            ysize: 32,
            zsize: 16,
            blocks: [],

            reset: function (xlen, ylen, zlen) {
                World.blocks = [];
                let layer = undefined;
                let line = undefined;
                for (let j = 0; j < ylen; j++) {
                    layer = [];
                    for (let k = 0; k < zlen; k++) {
                        line = [];
                        for (let i = 0; i < xlen; i++) {
                            line.push(["block:air", false]);
                        }
                        layer.push(line);
                    }
                    World.blocks.push(layer);
                }
            },

            getBlockDat: function (x, y, z) {
                if (World.blocks[y] === undefined) {
                    return ["block:air", false];
                } else if (World.blocks[y][z] === undefined) {
                    return ["block:air", false];
                } else if (World.blocks[y][z][x] === undefined) {
                    return ["block:air", false];
                } else {
                    return World.blocks[y][z][x];
                }
            },

            setBlock: function (block, x, y, z) {
                if (x >= 0 && x < World.xsize && y >= 0 && y < World.ysize && z >= 0 && z < World.zsize) {
                    World.blocks[y][z][x][0] = block;

                    Render.forceAddUpdate(x, y, z);

                    Render.addUpdate(x + 1, y, z);
                    Render.addUpdate(x - 1, y, z);
                    Render.addUpdate(x, y + 1, z);
                    Render.addUpdate(x, y - 1, z);
                    Render.addUpdate(x, y, z + 1);
                    Render.addUpdate(x, y, z - 1);
                }
            },
        };

        // =======================================================================================
        // ------- TEXTURES -------
        // To add new textures:
        // 1. add texture to Srcs
        // 2. add texture to texMap
        // 3. assign src
        // 4. map srcs texture to texMap

        const Srcs = {
            blocks: {
                grass: [
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                ],

                dirt: [
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                ],

                stone: [
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                ],

                cobblestone: [
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                ],
            },

            misc: {
                sky: [
                    new Image(),
                ],

                select: [
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                    new Image(),
                ],
            },

            ui: {
                crosshair: [
                    new Image(),
                ],
            },

            sys: {
                blockTexMap: [
                    "block:air", undefined,
                    "block:grass", undefined,
                    "block:dirt", undefined,
                    "block:stone", undefined,
                ],
            },
        };

        Srcs.blocks.grass[0].src = "textures/blocks/grass/side-tl.png";
        Srcs.blocks.grass[1].src = "textures/blocks/grass/side-br.png";
        Srcs.blocks.grass[2].src = "textures/blocks/grass/bottom-tl.png";
        Srcs.blocks.grass[3].src = "textures/blocks/grass/bottom-br.png";
        Srcs.blocks.grass[4].src = "textures/blocks/grass/top-tl.png";
        Srcs.blocks.grass[5].src = "textures/blocks/grass/top-br.png";

        Srcs.blocks.dirt[0].src = "textures/blocks/dirt/side-tl.png";
        Srcs.blocks.dirt[1].src = "textures/blocks/dirt/side-br.png";
        Srcs.blocks.dirt[2].src = "textures/blocks/dirt/bottom-tl.png";
        Srcs.blocks.dirt[3].src = "textures/blocks/dirt/bottom-br.png";
        Srcs.blocks.dirt[4].src = "textures/blocks/dirt/top-tl.png";
        Srcs.blocks.dirt[5].src = "textures/blocks/dirt/top-br.png";

        Srcs.blocks.stone[0].src = "textures/blocks/stone/side-tl.png";
        Srcs.blocks.stone[1].src = "textures/blocks/stone/side-br.png";
        Srcs.blocks.stone[2].src = "textures/blocks/stone/bottom-tl.png";
        Srcs.blocks.stone[3].src = "textures/blocks/stone/bottom-br.png";
        Srcs.blocks.stone[4].src = "textures/blocks/stone/top-tl.png";
        Srcs.blocks.stone[5].src = "textures/blocks/stone/top-br.png";

        Srcs.blocks.cobblestone[0].src = "textures/blocks/cobblestone/side-tl.png";
        Srcs.blocks.cobblestone[1].src = "textures/blocks/cobblestone/side-br.png";
        Srcs.blocks.cobblestone[2].src = "textures/blocks/cobblestone/bottom-tl.png";
        Srcs.blocks.cobblestone[3].src = "textures/blocks/cobblestone/bottom-br.png";
        Srcs.blocks.cobblestone[4].src = "textures/blocks/cobblestone/top-tl.png";
        Srcs.blocks.cobblestone[5].src = "textures/blocks/cobblestone/top-br.png";


        Srcs.misc.sky[0].src = "textures/misc/sky.png";

        Srcs.misc.select[0].src = "textures/misc/select.png";
        Srcs.misc.select[1].src = "textures/misc/select.png";
        Srcs.misc.select[2].src = "textures/misc/select.png";
        Srcs.misc.select[3].src = "textures/misc/select.png";
        Srcs.misc.select[4].src = "textures/misc/select.png";
        Srcs.misc.select[5].src = "textures/misc/select.png";

        Srcs.ui.crosshair[0].src = "textures/ui/crosshair.png";


        Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf("block:air") + 1] = null;
        Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf("block:grass") + 1] = Srcs.blocks.grass;
        Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf("block:dirt") + 1] = Srcs.blocks.dirt;
        Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf("block:stone") + 1] = Srcs.blocks.stone;
        Srcs.sys.blockTexMap[Srcs.sys.blockTexMap.indexOf("block:cobblestone") + 1] = Srcs.blocks.cobblestone;

        // =======================================================================================
        // ------- WORLD -------
        // keep World.reset() at the top

        World.reset(World.xsize, World.ysize, World.zsize);

        for (let i = 0; i < World.xsize; i++) {
            for (let j = 0; j < World.zsize; j++) {
                World.setBlock("block:stone", i, 0, j)
            }
        }
        for (let i = 0; i < World.xsize; i++) {
            for (let j = 0; j < World.zsize; j++) {
                World.setBlock("block:stone", i, 1, j)
            }
        }
        for (let i = 0; i < World.xsize; i++) {
            for (let j = 0; j < World.zsize; j++) {
                World.setBlock("block:dirt", i, 2, j)
            }
        }
        for (let i = 0; i < World.xsize; i++) {
            for (let j = 0; j < World.zsize; j++) {
                World.setBlock("block:grass", i, 3, j)
            }
        }

        // =======================================================================================

        Render.updateAll();

        setInterval(Sys.tick, 50);

    </script>
</body>

</html>
